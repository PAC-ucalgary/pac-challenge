<script>
  /* ==================== Animated Background ==================== */
  function initBackground(){
    if(prefersReduced) return;

    const canvas = document.getElementById('bgCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let w = 0, h = 0, rafId;

    // Floating glow "orbs"
    const orbs = [];
    const orbColors = ['#4cc9f0','#a3f7bf','#ffffff'];
    const ORB_COUNT = 6;

    // Twinkling stars
    const stars = [];
    const STAR_COUNT = Math.min(180, Math.floor(innerWidth * innerHeight / 15000));

    // ðŸ”º Glowing upside-down triangle (outline only)
    const tri = {
      cx: () => innerWidth * 0.5,
      cy: () => innerHeight * 0.42,     // a bit above center so it sits behind the cards nicely
      size: () => Math.min(innerWidth, innerHeight) * 0.62,
      angle: 0,
      spin: 0.0006,                      // slow, classy rotation
      pulsePhase: 0,
      dashOffset: 0
    };

    function resize(){
      dpr = Math.max(1, window.devicePixelRatio || 1);
      w = Math.floor(innerWidth * dpr);
      h = Math.floor(innerHeight * dpr);
      canvas.width = w; canvas.height = h;
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      ctx.setTransform(1,0,0,1,0,0);
      initStars();
    }

    function initOrbs(){
      orbs.length = 0;
      for(let i=0;i<ORB_COUNT;i++){
        const r = (Math.random()*0.25 + 0.18) * Math.min(innerWidth, innerHeight);
        const speed = (Math.random()*0.4 + 0.15) * (r/250);
        orbs.push({
          x: Math.random()*innerWidth,
          y: Math.random()*innerHeight,
          vx: (Math.random()*2-1)*speed,
          vy: (Math.random()*2-1)*speed,
          r,
          c: orbColors[i%orbColors.length],
          a: 0.10 + Math.random()*0.08
        });
      }
    }

    function initStars(){
      stars.length = 0;
      const count = STAR_COUNT;
      for(let i=0;i<count;i++){
        stars.push({
          x: Math.random()*w,
          y: Math.random()*h,
          r: Math.random()*1.8 + 0.6,
          tw: Math.random()*Math.PI*2,
          sp: 0.005 + Math.random()*0.01
        });
      }
    }

    function drawOrbs(){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for(const o of orbs){
        const gx = o.x * dpr, gy = o.y * dpr, gr = o.r * dpr;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, gr);
        g.addColorStop(0, `rgba(76,201,240,${o.a})`);
        g.addColorStop(1, `rgba(76,201,240,0)`);
        if(o.c === '#a3f7bf'){
          g.addColorStop(0, `rgba(163,247,191,${o.a})`);
        }
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(gx, gy, gr, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    function updateOrbs(){
      for(const o of orbs){
        o.x += o.vx; o.y += o.vy;
        if(o.x < -o.r) o.x = innerWidth + o.r;
        if(o.x > innerWidth + o.r) o.x = -o.r;
        if(o.y < -o.r) o.y = innerHeight + o.r;
        if(o.y > innerHeight + o.r) o.y = -o.r;
      }
    }

    function drawStars(){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = '#ffffff';
      for(const s of stars){
        s.tw += s.sp;
        const alpha = 0.25 + 0.75 * (0.5 + Math.sin(s.tw)*0.5);
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // ðŸ”º Triangle path helper (equilateral, pointing DOWN)
    function trianglePath(cx, cy, size){
      const h = Math.sqrt(3)/2 * size;         // height of equilateral
      const x1 = cx;           const y1 = cy + h/2;   // bottom apex
      const x2 = cx - size/2;  const y2 = cy - h/2;   // top-left
      const x3 = cx + size/2;  const y3 = cy - h/2;   // top-right
      ctx.beginPath();
      ctx.moveTo(x1*dpr, y1*dpr);
      ctx.lineTo(x2*dpr, y2*dpr);
      ctx.lineTo(x3*dpr, y3*dpr);
      ctx.closePath();
    }

    function drawTriangle(t){
      // Pulse between 0.35â€“0.75 opacity
      const pulse = 0.55 + 0.20*Math.sin(tri.pulsePhase);
      const cx = tri.cx(), cy = tri.cy(), s = tri.size();

      ctx.save();
      ctx.translate(cx*dpr, cy*dpr);
      ctx.rotate(tri.angle);
      ctx.translate(-cx*dpr, -cy*dpr);

      // Outer soft halo
      ctx.save();
      trianglePath(cx, cy, s*1.02);
      ctx.globalCompositeOperation = 'lighter';
      ctx.lineWidth = 12*dpr;
      ctx.strokeStyle = 'rgba(255, 59, 59, 0.12)'; // soft red halo
      ctx.shadowColor = 'rgba(255, 80, 80, 0.9)';
      ctx.shadowBlur  = 40*dpr;
      ctx.stroke();
      ctx.restore();

      // Main glowing stroke
      ctx.save();
      trianglePath(cx, cy, s);
      ctx.globalCompositeOperation = 'screen';
      ctx.lineWidth = 3.5*dpr;
      ctx.strokeStyle = `rgba(255, 59, 59, ${pulse})`;
      ctx.shadowColor = 'rgba(255, 80, 80, 0.85)';
      ctx.shadowBlur = 18*dpr;
      // Shimmering dash pass
      ctx.setLineDash([16*dpr, 12*dpr]);
      ctx.lineDashOffset = tri.dashOffset;
      ctx.stroke();
      ctx.restore();

      // Bright specular "shine" that sweeps along the dash
      ctx.save();
      trianglePath(cx, cy, s);
      const grad = ctx.createLinearGradient((cx-s/2)*dpr, (cy+h/2)*dpr, (cx+s/2)*dpr, (cy-h/2)*dpr);
      grad.addColorStop(0, 'rgba(255,255,255,0)');
      grad.addColorStop(0.5, 'rgba(255,255,255,0.35)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.globalCompositeOperation = 'screen';
      ctx.lineWidth = 1.2*dpr;
      ctx.strokeStyle = grad;
      ctx.setLineDash([22*dpr, 9999]); // thin moving highlight
      ctx.lineDashOffset = -tri.dashOffset*1.2;
      ctx.stroke();
      ctx.restore();

      ctx.restore();
    }

    let lastTs = 0;
    function tick(ts=0){
      const dt = (ts - lastTs) || 16; // ms
      lastTs = ts;

      // Update tri animation
      tri.angle += tri.spin * dt;
      tri.pulsePhase += 0.0032 * dt;
      tri.dashOffset -= 0.06 * dt;

      ctx.clearRect(0,0,w,h);
      drawStars();
      drawTriangle(ts);  // ðŸ”º draw behind orbs for depth
      drawOrbs();
      updateOrbs();

      rafId = requestAnimationFrame(tick);
    }

    resize();
    initOrbs();
    tick();

    window.addEventListener('resize', ()=>{
      cancelAnimationFrame(rafId);
      resize(); initOrbs();
      tick();
    }, { passive:true });
  }
</script>
